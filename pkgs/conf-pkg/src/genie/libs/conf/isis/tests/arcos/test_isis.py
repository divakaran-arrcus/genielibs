#!/usr/bin/env python3
"""Unit tests for native Genie ArcOS ISIS config plugin.

These tests exercise the native `genie.libs.conf.isis.arcos` plugin
without importing `arrcus_pyats.config.isis`. They verify that the
ArcOS ISIS CLI generated by Genie matches the expected ArcOS shapes
for basic (Phase-1) global and interface-level configuration.
"""

import unittest
from unittest.mock import Mock

from genie.conf import Genie
from genie.conf.base import Testbed, Device, Interface
from genie.libs.conf.isis import Isis as GenieIsis
from genie.libs.conf.address_family import AddressFamily


class TestNativeArcosIsisBasic(unittest.TestCase):
    """Basic global and interface-level ISIS config for ArcOS."""

    def setUp(self):
        # Create an in-memory testbed and a single ArcOS device
        testbed = Genie.testbed = Testbed()
        self.device = Device(testbed=testbed, name="rtr1", os="arcos", type="router")
        # ArcOS network-instance name used by the plugin (default)
        self.device.custom = {"instance_name": "default"}
        # Stub out configure so no real device interaction happens
        self.device.configure = Mock(return_value=True)

        # One data-plane interface
        self.intf1 = Interface(name="swp1", device=self.device)

    def test_basic_global_and_levels(self):
        """Verify NET + level capability + level stanzas."""
        isis = GenieIsis(pid="default")

        da = isis.device_attr[self.device]
        da.net = ["49.0000.0000.0000.0005.00"]
        da.is_type = GenieIsis.IsType.level_1_2

        # Explicitly pass the target device so Genie includes it in cfgs
        cfgs = isis.build_config(devices=[self.device], apply=False)
        # Ensure device entry exists
        self.assertIn("rtr1", cfgs)

        cfg_str = str(cfgs["rtr1"])

        # Global context
        self.assertIn("network-instance default", cfg_str)
        self.assertIn("protocol ISIS default", cfg_str)
        self.assertIn("global net [ 49.0000.0000.0000.0005.00 ]", cfg_str)

        # Level-capability and per-level stanzas
        self.assertIn("global level-capability LEVEL_1_2", cfg_str)
        self.assertIn("level 1", cfg_str)
        self.assertIn("level 2", cfg_str)
        self.assertIn("enabled true", cfg_str)

    def test_global_address_families(self):
        """Verify global IPv4/IPv6 AFs and IPv6 multi-topology."""
        isis = GenieIsis(pid="default")

        da = isis.device_attr[self.device]
        da.net_id = "49.0000.0000.0000.0005.00"
        da.is_type = GenieIsis.IsType.level_2

        # Enable both AFs and turn on IPv6 multi-topology
        af_ipv4 = da.address_family_attr[AddressFamily.ipv4_unicast]
        af_ipv6 = da.address_family_attr[AddressFamily.ipv6_unicast]
        af_ipv4.enabled = True
        af_ipv6.enabled = True
        af_ipv6.ipv6_multi_topology = True

        # Explicitly pass the target device so Genie includes it in cfgs
        cfgs = isis.build_config(devices=[self.device], apply=False)
        cfg_str = str(cfgs["rtr1"])

        self.assertIn("global af IPV4 UNICAST", cfg_str)
        self.assertIn("global af IPV6 UNICAST", cfg_str)
        self.assertIn("multi-topology enabled true", cfg_str)

    def test_interface_basic(self):
        """Verify basic per-interface ISIS configuration for ArcOS."""
        isis = GenieIsis(pid="default")

        # Attach ISIS feature to interface
        self.intf1.add_feature(isis)

        da = isis.device_attr[self.device]
        da.net_id = "49.0000.0000.0000.0005.00"
        da.is_type = GenieIsis.IsType.level_2

        ia = da.interface_attr[self.intf1]
        ia.enabled = True
        ia.if_type = "point-to-point"
        ia.interface_id = "swp1"
        ia.hello_interval = 10
        ia.hello_multiplier = 3
        ia.metric_level2 = 20

        # Explicitly pass the target device so Genie includes it in cfgs
        cfgs = isis.build_config(devices=[self.device], apply=False)
        cfg_str = str(cfgs["rtr1"])

        # Interface stanza
        self.assertIn("interface swp1", cfg_str)
        self.assertIn("enabled      true", cfg_str)
        self.assertIn("network-type POINT_TO_POINT", cfg_str)

        # Interface AFs
        self.assertIn("af IPV6 UNICAST", cfg_str)
        self.assertIn("af IPV4 UNICAST", cfg_str)

        # Timers and metrics
        self.assertIn("timers hello-interval 10", cfg_str)
        self.assertIn("timers hello-multiplier 3", cfg_str)
        self.assertIn("level 2 metric 20", cfg_str)

    def test_unconfig_whole_protocol(self):
        """Verify that build_unconfig removes the ISIS protocol subtree."""
        isis = GenieIsis(pid="default")

        da = isis.device_attr[self.device]
        da.net_id = "49.0000.0000.0000.0005.00"
        da.is_type = GenieIsis.IsType.level_2

        # Explicitly pass the target device so Genie includes it in cfgs
        cfgs = isis.build_unconfig(devices=[self.device], apply=False)
        cfg_str = str(cfgs["rtr1"])

        # CliConfigBuilder(unconfig=True) should prefix with 'no '
        self.assertIn("no network-instance default protocol ISIS default", cfg_str)


if __name__ == "__main__":
    unittest.main(verbosity=2)
